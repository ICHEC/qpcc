<!DOCTYPE html>
<html>
<head>
    <title>Interactive Bloch Sphere</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: white; }
        canvas { display: block; }
        
        /* New Styles for the 2D Map */
        #map-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background-color: #f0f0f0;
            border: 2px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            color: #333;
            font-family: Arial, sans-serif;
            user-select: none;
        }
        /* Change 1: Larger rectangle size (e.g., 300px wide, 150px high) */
        #theta-phi-map {
            width: 200px;
            height: 100px; 
            background: linear-gradient(to right, #e0e0e0, #ffffff);
            position: relative;
            cursor: crosshair;
        }
        #map-point {
            width: 12px; /* Slightly larger dot */
            height: 12px;
            background-color: red;
            border: 2px solid black;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <h4>θ-φ Plane</h4>
        <p>
            θ: <span id="theta-display">0.00</span>&deg;, 
            φ: <span id="phi-display">0.00</span>&deg;
        </p>
        <div id="theta-phi-map">
            <div id="map-point"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Global State Variables ---
        const state = {
            theta_deg: 0, 
            phi_deg: 0    
        };

        // --- DOM Elements ---
        const mapElement = document.getElementById('theta-phi-map');
        const mapPoint = document.getElementById('map-point');
        const thetaDisplay = document.getElementById('theta-display');
        const phiDisplay = document.getElementById('phi-display');

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0xffffff); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.z = 3;

        // Lighting
        scene.add(new THREE.AmbientLight(0x606060));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Bloch Sphere (main translucent sphere)
        const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
        const sphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x4444ff, transparent: true, opacity: 0.1, wireframe: true
        });
        const blochSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(blochSphere);

        // Axes and Labels (No change from previous step)
        const axisLength = 1.5;
        const arrowHelperX = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), axisLength, 0xff0000, 0.2, 0.1);
        const arrowHelperY = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), axisLength, 0x00ff00, 0.2, 0.1);
        const arrowHelperZ = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), axisLength, 0x0000ff, 0.2, 0.1);
        
        scene.add(arrowHelperX, arrowHelperY, arrowHelperZ);
        
        function createLabel(text, color, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 64;
            context.font = 'Bold 18pt Arial'; context.fillStyle = color;
            context.fillText(text, 5, 30);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.6, 0.3, 1);
            sprite.position.copy(position);
            return sprite;
        }

        scene.add(createLabel('|0⟩ (+Z)', 'darkblue', new THREE.Vector3(0, 1.2, 0)));
        scene.add(createLabel('|1⟩ (-Z)', 'darkblue', new THREE.Vector3(0, -1.2, 0)));
        scene.add(createLabel('|+⟩ (+X)', 'darkred', new THREE.Vector3(1.2, 0, 0)));


        // --- Quantum State Vector (Arrow) ---
        const initialVector = new THREE.Vector3(0, 1, 0); 
        const stateVector = new THREE.ArrowHelper(initialVector, new THREE.Vector3(0, 0, 0), 1, 0xAA00AA, 0.2, 0.1);
        scene.add(stateVector);

        // Change 2: Small sphere at the tip of the vector
        const dotGeometry = new THREE.SphereGeometry(0.05, 16, 16); // Radius 0.05
        const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color
        const stateDot = new THREE.Mesh(dotGeometry, dotMaterial);
        scene.add(stateDot);
        
        // --- State Update Function ---
        function updateBlochState() {
            // 1. Convert degrees to radians
            const theta = state.theta_deg * (Math.PI / 180);
            const phi = state.phi_deg * (Math.PI / 180);

            // 2. Calculate Bloch Vector (x_B, y_B, z_B)
            const x_B = Math.sin(theta) * Math.cos(phi);
            const y_B = Math.sin(theta) * Math.sin(phi);
            const z_B = Math.cos(theta);

            // 3. Map Bloch Vector to Three.js Coordinates (x_T, y_T, z_T)
            const x_T = x_B;
            const y_T = z_B; // Bloch Z is Three.js Y (Vertical)
            const z_T = y_B; // Bloch Y is Three.js Z
            
            const newDirection = new THREE.Vector3(x_T, y_T, z_T);
            
            // Update the state vector's arrow direction
            stateVector.setDirection(newDirection);

            // Update the state dot's position (it's placed at the tip of the unit vector)
            stateDot.position.copy(newDirection);

            // Update 2D Map Displays
            thetaDisplay.textContent = state.theta_deg.toFixed(2);
            phiDisplay.textContent = state.phi_deg.toFixed(2);
        }

        
        // --- 2D Map Interaction Logic (No functional change) ---
        function onMapDrag(event) {
            const rect = mapElement.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            x = Math.max(0, Math.min(x, rect.width));
            y = Math.max(0, Math.min(y, rect.height));

            // Phi (Horizontal: 0 to 360)
            state.phi_deg = (x / rect.width) * 360; 
            
            // Theta (Vertical: 0 to 180)
            state.theta_deg = (y / rect.height) * 180; 

            // Update the red dot position on the map
            mapPoint.style.left = `${x}px`;
            mapPoint.style.top = `${y}px`;
            
            updateBlochState();
        }

        function setupMapControls() {
            let isDragging = false;

            mapElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                onMapDrag(e);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    onMapDrag(e);
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Set initial position of the map point (for theta=0, phi=0)
            const initialX = 0;
            const initialY = 0;
            mapPoint.style.left = `${initialX}px`;
            mapPoint.style.top = `${initialY}px`;
            
            updateBlochState();
        }

        // --- Initialization and Animation Loop ---
        setupMapControls();
        updateBlochState();

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 
            renderer.render(scene, camera);
        }

        animate();

        // --- Handle window resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>
</html>
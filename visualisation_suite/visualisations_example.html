<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Comprehensive Math Visualization Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/1.4.6/jsxgraphcore.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/1.4.6/jsxgraph.css">
    <!-- Import our enhanced math visualizer module -->
    <link rel="stylesheet" href="math_visualiser.css">
    <script src="math_visualiser.js"></script>
    
</head>
<body>
    <div class="container">
        <h1>Comprehensive Math Visualization Demo</h1>
        <p style="text-align: center; margin-bottom: 30px;">Interactive visualizations for Leaving Cert mathematics curriculum</p>
        
        <!-- FUNCTIONS SECTION -->
        <div class="section-header">
            <h2>Functions</h2>
        </div>
        
        <div class="visualization-row">
            <!-- Quadratic Function Container -->
            <div class="visualization-container" id="quadratic-container">
                <!-- JSXGraph board will be created here -->
            </div>
            
            <!-- Trigonometric Function Container -->
            <div class="visualization-container" id="trig-container">
                <!-- JSXGraph board will be created here -->
            </div>
        </div>
        
        <div class="visualization-row">
            <!-- Function Transformations Container -->
            <div class="visualization-container" id="transformation-container">
                <!-- JSXGraph board will be created here -->
            </div>
            
            <!-- Exponential & Logarithmic Container -->
            <div class="visualization-container" id="exp-log-container">
                <!-- JSXGraph board will be created here -->
            </div>
        </div>
        
        <!-- CALCULUS SECTION -->
        <div class="section-header">
            <h2>Calculus</h2>
        </div>
        
        <div class="visualization-row">
            <!-- Derivatives Container -->
            <div class="visualization-container" id="derivatives-container">
                <!-- JSXGraph board will be created here -->
            </div>
            
            <!-- Integration Container -->
            <div class="visualization-container" id="integration-container">
                <!-- JSXGraph board will be created here -->
            </div>
        </div>
        
        <!-- GEOMETRY SECTION -->
        <div class="section-header">
            <h2>Geometry</h2>
        </div>
        
        <div class="visualization-row">
            <!-- Circle Geometry Container -->
            <div class="visualization-container" id="circle-geometry-container">
                <!-- JSXGraph board will be created here -->
            </div>
            
            <!-- Triangle Geometry Container -->
            <div class="visualization-container" id="triangle-container">
                <!-- JSXGraph board will be created here -->
            </div>
        </div>
        
        <!-- STATISTICS SECTION -->
        <div class="section-header">
            <h2>Statistics & Probability</h2>
        </div>
        
        <div class="visualization-row">
            <!-- Normal Distribution Container -->
            <div class="visualization-container" id="normal-dist-container">
                <!-- JSXGraph board will be created here -->
            </div>
            
            <!-- Linear Regression Container -->
            <div class="visualization-container" id="regression-container">
                <!-- JSXGraph board will be created here -->
            </div>
        </div>
        <div class="section-header">
            <h2>Probability & Histograms</h2>
        </div>
        
        <div class="visualization-row">
            <!-- Probability & Histogram Container -->
            <div class="visualization-container" id="probability-container">
                <!-- JSXGraph board will be created here -->
            </div>
        </div>
    </div>

    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing mathematical visualizations...");
            
            // Initialize the Math Visualizer
            MathVisualizer.initMathVisualizer();
            
            //----------------------------------------------
            // FUNCTIONS SECTION
            //----------------------------------------------
            
            // 1. Quadratic Function
            const quadraticGraph = MathVisualizer.createGraphFromDescription('quadratic-container', {
                boundingBox: [-5, 5, 5, -5],
                theme: 'light',
                useSequentialColors: true,
                
                infoBox: {
                    title: "Quadratic Function",
                    lines: [
                        {text: "y = a·x² + b·x + c", dynamic: false},
                        {text: "Discriminant: ${b^2-4*a*c}", dynamic: true},
                        {text: "Vertex: (${-b/(2*a)}, ${c-b^2/(4*a)})", dynamic: true},
                        {text: "y-intercept: ${c}", dynamic: true}
                    ],
                    position: {top: 59, left: 20}
                },
                
                parametrizedFunctions: [
                    {
                        expression: 'a*x^2 + b*x + c',
                        title: 'Quadratic Function Explorer',
                        parameters: {
                            a: { min: -2, max: 2, value: 1, step: 0.1 },
                            b: { min: -5, max: 5, value: 0, step: 0.1 },
                            c: { min: -5, max: 5, value: 0, step: 0.1 }
                        },
                        features: ['zeros', 'extrema']
                    }
                ]
            });
            
            // 2. Trigonometric Function
            const trigGraph = MathVisualizer.createGraphFromDescription('trig-container', {
                boundingBox: [-6.28, 3, 6.28, -3],
                theme: 'dark', 
                useSequentialColors: true,
                
                infoBox: {
                    title: "Trigonometric Function",
                    lines: [
                        {text: "y = a·sin(b·x + c) + d", dynamic: false},
                        {text: "Amplitude: ${Math.abs(a)}", dynamic: true},
                        {text: "Period: ${2*Math.PI/b}", dynamic: true},
                        {text: "Phase Shift: ${-c/b}", dynamic: true},
                        {text: "Vertical Shift: ${d}", dynamic: true}
                    ],
                    position: {top: 65, left: 20}
                },
                
                parametrizedFunctions: [
                    {
                        expression: 'a*sin(b*x + c) + d',
                        title: 'Sine Wave Explorer',
                        parameters: {
                            a: { min: -3, max: 3, value: 1, step: 0.1 },
                            b: { min: 0.1, max: 3, value: 1, step: 0.1 },
                            c: { min: -Math.PI, max: Math.PI, value: 0, step: 0.1 },
                            d: { min: -3, max: 3, value: 0, step: 0.1 }
                        },
                        features: ['zeros', 'extrema']
                    }
                ]
            });
            
            // 3. Function Transformations
            const transformationGraph = MathVisualizer.createGraphFromDescription('transformation-container', {
                boundingBox: [-5, 5, 5, -5],
                theme: 'light',
                useSequentialColors: true,
                
                infoBox: {
                    title: "Function Transformations",
                    lines: [
                        {text: "y = a·f(b·(x - h)) + k", dynamic: false},
                        {text: "Vertical Stretch: ${a}", dynamic: true},
                        {text: "Horizontal Stretch: ${1/b}", dynamic: true},
                        {text: "Horizontal Shift: ${h}", dynamic: true},
                        {text: "Vertical Shift: ${k}", dynamic: true}
                    ],
                    position: {top: 65, left: 20}
                },
                
                parametrizedFunctions: [
                    {
                        expression: 'a*((b*(x-h))^2) + k',
                        title: 'Function Transformations',
                        parameters: {
                            a: { min: -2, max: 2, value: 1, step: 0.1 },
                            b: { min: 0.1, max: 2, value: 1, step: 0.1 },
                            h: { min: -3, max: 3, value: 0, step: 0.1 },
                            k: { min: -3, max: 3, value: 0, step: 0.1 }
                        },
                        features: ['zeros', 'extrema']
                    }
                ],
                
                // Add original function for comparison
                elements: [
                    {
                        type: 'functiongraph',
                        data: [function(x) { return x*x; }, -5, 5],
                        properties: { 
                            strokeColor: '#bbbbbb',
                            strokeWidth: 1,
                            dash: 2
                        }
                    },
                    {
                        type: 'text',
                        data: [-4.5, 4.5, 'Original: y = x²'],
                        properties: { 
                            fontSize: 14,
                            anchorX: 'left'
                        }
                    }
                ]
            });
            
            // 4. Exponential & Logarithmic Functions
            const expLogGraph = MathVisualizer.createGraphFromDescription('exp-log-container', {
                boundingBox: [-2, 8, 8, -2],
                theme: 'dark',
                useSequentialColors: true,
                
                infoBox: {
                    title: "Exponential & Logarithmic",
                    lines: [
                        {text: "Exponential: y = a·bˣ", dynamic: false},
                        {text: "Logarithmic: y = c·log₍ᵦ₎(x)", dynamic: false},
                        {text: "Base (b): ${b}", dynamic: true},
                        {text: "Exp. Coefficient (a): ${a}", dynamic: true},
                        {text: "Log. Coefficient (c): ${c}", dynamic: true}
                    ],
                    position: {top: 65, left: 20}
                },
                
                elements: [
                    // We'll add both functions as elements instead of parametrized
                    // Because we want to show two functions simultaneously
                    {
                        type: 'functiongraph',
                        data: [function(x) { return 2 * Math.pow(2, x); }, -2, 8],
                        properties: { 
                            strokeColor: '#3498db',
                            strokeWidth: 2,
                            name: 'Exponential'
                        }
                    },
                    {
                        type: 'functiongraph',
                        data: [function(x) { return x <= 0 ? NaN : 3 * Math.log(x) / Math.log(2); }, 0, 8],
                        properties: { 
                            strokeColor: '#e74c3c',
                            strokeWidth: 2,
                            name: 'Logarithmic'
                        }
                    },
                    {
                        type: 'line',
                        data: [[0, 0], [1, 1]],
                        properties: { 
                            strokeColor: '#95a5a6',
                            strokeWidth: 1,
                            dash: 2,
                            straightFirst: true,
                            straightLast: true
                        }
                    },
                    {
                        type: 'text',
                        data: [6, 6.5, 'y = a·bˣ'],
                        properties: { 
                            fontSize: 14,
                            anchorX: 'left',
                            color: '#3498db'
                        }
                    },
                    {
                        type: 'text',
                        data: [6, 5.5, 'y = c·log₍ᵦ₎(x)'],
                        properties: { 
                            fontSize: 14,
                            anchorX: 'left',
                            color: '#e74c3c'
                        }
                    }
                ],
                
                parametrizedFunctions: [
                    {
                        // This is a dummy to enable parameters - we're using elements for the actual functions
                        expression: '0',
                        parameters: {
                            a: { min: 0.1, max: 5, value: 2, step: 0.1 },
                            b: { min: 1.1, max: 5, value: 2, step: 0.1 },
                            c: { min: 0.1, max: 5, value: 3, step: 0.1 }
                        }
                    }
                ]
            });
            
            // Add event listener to update the functions when parameters change
            // Add event listener to update the functions when parameters change
            expLogGraph.board.on('update', function() {
                const a = expLogGraph.parameterValues.a;
                const b = expLogGraph.parameterValues.b;
                const c = expLogGraph.parameterValues.c;
                
                // Find our functions by their color or other unique property
                for (let id in expLogGraph.board.objects) {
                    const obj = expLogGraph.board.objects[id];
                    
                    if (obj.elType === 'curve') {
                        // Exponential function (blue)
                        if (obj.visProp && obj.visProp.strokecolor === '#3498db') {
                            obj.Y = function(x) { 
                                return a * Math.pow(b, x); 
                            };
                        }
                        // Logarithmic function (red)
                        else if (obj.visProp && obj.visProp.strokecolor === '#e74c3c') {
                            obj.Y = function(x) { 
                                return x <= 0 ? NaN : c * Math.log(x) / Math.log(b); 
                            };
                        }
                    }
                }
                
                // Make sure to update the board
                expLogGraph.board.update();
            });
            
            //----------------------------------------------
            // CALCULUS SECTION
            //----------------------------------------------
            
            // 5. Derivatives
            const derivativesGraph = MathVisualizer.createGraphFromDescription('derivatives-container', {
                boundingBox: [-5, 5, 5, -5],
                theme: 'light',
                useSequentialColors: true,
                
                infoBox: {
                    title: "Derivatives",
                    lines: [
                        {text: "f(x) = ax³ + bx² + cx + d", dynamic: false},
                        {text: "f'(x) = 3ax² + 2bx + c", dynamic: false},
                        {text: "At x₀ = ${x0}:", dynamic: true},
                        {text: "f(x₀) = ${a*x0^3 + b*x0^2 + c*x0 + d}", dynamic: true},
                        {text: "f'(x₀) = ${3*a*x0^2 + 2*b*x0 + c}", dynamic: true},
                        {text: "Slope at x₀: ${3*a*x0^2 + 2*b*x0 + c}", dynamic: true}
                    ],
                    position: {top: 65, left: 20}
                },
                
                parametrizedFunctions: [
                    {
                        expression: 'a*x^3 + b*x^2 + c*x + d',
                        title: 'Derivative Explorer',
                        parameters: {
                            a: { min: -0.5, max: 0.5, value: 0.1, step: 0.005 },
                            b: { min: -2, max: 2, value: 0.5, step: 0.01 },
                            c: { min: -3, max: 3, value: -1, step: 0.01 },
                            d: { min: -3, max: 3, value: 0, step: 0.01 },
                            x0: { min: -5, max: 5, value: 1, step: 0.01 }
                        }
                    }
                ]
            });

            // Store references to the important elements
            let derivativePoint = null;
            let derivativeTangent = null;
            let derivativeFunction = null;

            // Create the initial derivative elements
            function createDerivativeElements() {
                // Get current parameters
                const a = derivativesGraph.parameterValues.a;
                const b = derivativesGraph.parameterValues.b;
                const c = derivativesGraph.parameterValues.c;
                const d = derivativesGraph.parameterValues.d;
                const x0 = derivativesGraph.parameterValues.x0;
                
                // Calculate initial values
                const fx0 = a * Math.pow(x0, 3) + b * Math.pow(x0, 2) + c * x0 + d;
                const dfx0 = 3 * a * Math.pow(x0, 2) + 2 * b * x0 + c;
                
                // Create point on curve
                derivativePoint = derivativesGraph.board.create('point', [x0, fx0], {
                    name: 'P',
                    size: 4,
                    fillColor: '#e74c3c',
                    strokeColor: '#ffffff'
                });
                
                // Create tangent line
                const x1 = x0 - 2;
                const y1 = fx0 - dfx0 * 2;
                const x2 = x0 + 2;
                const y2 = fx0 + dfx0 * 2;
                derivativeTangent = derivativesGraph.board.create('line', [[x1, y1], [x2, y2]], {
                    strokeColor: '#3498db',
                    strokeWidth: 2,
                    dash: 2
                });
                
                // Create derivative function
                derivativeFunction = derivativesGraph.board.create('functiongraph', 
                    [function(x) { return 3 * a * Math.pow(x, 2) + 2 * b * x + c; }, -30, 30], {
                        strokeColor: '#2ecc71',
                        strokeWidth: 2
                    }
                );
                
                // Add label for derivative
                derivativesGraph.board.create('text', [-4.5, -4, "f'(x)"], {
                    fontSize: 14,
                    color: '#2ecc71'
                });
            }

            // Create the initial elements
            createDerivativeElements();

            // Update derivative elements when parameters change
            derivativesGraph.board.on('update', function() {
                // Get current parameters
                const a = derivativesGraph.parameterValues.a;
                const b = derivativesGraph.parameterValues.b;
                const c = derivativesGraph.parameterValues.c;
                const d = derivativesGraph.parameterValues.d;
                const x0 = derivativesGraph.parameterValues.x0;
                
                // Calculate function value at x0
                const fx0 = a * Math.pow(x0, 3) + b * Math.pow(x0, 2) + c * x0 + d;
                
                // Calculate derivative at x0
                const dfx0 = 3 * a * Math.pow(x0, 2) + 2 * b * x0 + c;
                
                // Update point on curve
                if (derivativePoint && derivativePoint.moveTo) {
                    derivativePoint.moveTo([x0, fx0]);
                }
                
                // Update tangent line
                if (derivativeTangent && derivativeTangent.point1 && derivativeTangent.point2) {
                    const x1 = x0 - 2;
                    const y1 = fx0 - dfx0 * 2;
                    const x2 = x0 + 2;
                    const y2 = fx0 + dfx0 * 2;
                    
                    derivativeTangent.point1.moveTo([x1, y1]);
                    derivativeTangent.point2.moveTo([x2, y2]);
                }
                
                // Update derivative function
                if (derivativeFunction && derivativeFunction.Y) {
                    derivativeFunction.Y = function(x) {
                        return 3 * a * Math.pow(x, 2) + 2 * b * x + c;
                    };
                }
            });
            // 6. Integration
            // 6. Integration with interactive rectangle count
            const integrationGraph = MathVisualizer.createGraphFromDescription('integration-container', {
                boundingBox: [-5, 5, 5, -5],
                theme: 'dark',
                useSequentialColors: true,
                
                infoBox: {
                    title: "Integration",
                    lines: [
                        {text: "f(x) = ax² + bx + c", dynamic: false},
                        {text: "∫f(x)dx from ${lower} to ${upper}", dynamic: true},
                        {text: "Area = ${(1/3)*a*(upper^3-lower^3) + (1/2)*b*(upper^2-lower^2) + c*(upper-lower)}", dynamic: true},
                        {text: "Rectangles: ${rectangles}", dynamic: true}  // Added display for rectangle count
                    ],
                    position: {top: 65, left: 20}
                },
                
                parametrizedFunctions: [
                    {
                        expression: 'a*x^2 + b*x + c',
                        title: 'Integration Explorer',
                        parameters: {
                            a: { min: -2, max: 2, value: 0.5, step: 0.1 },
                            b: { min: -4, max: 4, value: -1, step: 0.1 },
                            c: { min: -3, max: 3, value: 0, step: 0.1 },
                            lower: { min: -4, max: 3.9, value: -2, step: 0.1 },
                            upper: { min: -3.9, max: 4, value: 2, step: 0.1 },
                            rectangles: { min: 1, max: 100, value: 20, step: 1 }  // Added rectangles parameter
                        }
                    }
                ]
            });

            // Create the function for integration
            const integrationFunction = function(x) { 
                return integrationGraph.parameterValues.a * x * x + 
                    integrationGraph.parameterValues.b * x + 
                    integrationGraph.parameterValues.c; 
            };

            // Create dropdown for Riemann sum type
            const typesContainer = document.createElement('div');
            typesContainer.style.position = 'absolute';
            typesContainer.style.bottom = '130px';
            typesContainer.style.left = '20px';
            typesContainer.style.zIndex = '10';
            typesContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.85)';
            typesContainer.style.padding = '10px';
            typesContainer.style.borderRadius = '8px';
            typesContainer.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            typesContainer.innerHTML = `
                <label for="riemann-type" style="margin-right: 8px; font-weight: 600;">Type:</label>
                <select id="riemann-type" style="padding: 4px; border-radius: 4px;">
                    <option value="left">Left sum</option>
                    <option value="right">Right sum</option>
                    <option value="middle">Middle sum</option>
                    <option value="trapezium" selected>Trapezium</option>
                </select>
            `;

            // Append the dropdown to the container
            document.getElementById('integration-container').appendChild(typesContainer);

            // Get the select element
            const typeSelect = document.getElementById('riemann-type');

            // Store the currently selected type
            let currentRiemannType = 'trapezium';

            // Add event listener for type change
            typeSelect.addEventListener('change', function() {
                currentRiemannType = this.value;
                
                // Re-create the riemannsum with the new type
                if (areaPolygon) {
                    integrationGraph.board.removeObject(areaPolygon);
                }
                
                createRiemannSum();
                integrationGraph.board.update();
            });

            // Create the riemannsum element
            let areaPolygon;

            function createRiemannSum() {
                areaPolygon = integrationGraph.board.create('riemannsum', [
                    integrationFunction,
                    function() { return integrationGraph.parameterValues.rectangles; }, // number of rectangles from slider
                    function() { return currentRiemannType; }, // type from dropdown
                    function() { return integrationGraph.parameterValues.lower; },
                    function() { return integrationGraph.parameterValues.upper; }
                ], {
                    fillColor: '#3498db',
                    fillOpacity: 0.4,
                    strokeColor: '#3498db',
                    strokeWidth: 1
                });
            }

            // Initial creation
            createRiemannSum();

            // Add vertical lines for bounds
            const lowerLine = integrationGraph.board.create('line', 
                [[integrationGraph.parameterValues.lower, 0], 
                [integrationGraph.parameterValues.lower, integrationFunction(integrationGraph.parameterValues.lower)]], 
                {
                    strokeColor: '#e74c3c', 
                    strokeWidth: 2, 
                    dash: 2, 
                    straightFirst: false, 
                    straightLast: false
                }
            );

            const upperLine = integrationGraph.board.create('line', 
                [[integrationGraph.parameterValues.upper, 0], 
                [integrationGraph.parameterValues.upper, integrationFunction(integrationGraph.parameterValues.upper)]], 
                {
                    strokeColor: '#e74c3c', 
                    strokeWidth: 2, 
                    dash: 2, 
                    straightFirst: false, 
                    straightLast: false
                }
            );

            // Update vertical lines for bounds when parameters change
            integrationGraph.board.on('update', function() {
                // Get current parameters
                const lower = integrationGraph.parameterValues.lower;
                const upper = integrationGraph.parameterValues.upper;
                
                // Calculate y-values
                const lowerY = integrationFunction(lower);
                const upperY = integrationFunction(upper);
                
                // Update vertical lines for bounds
                if (lowerLine && lowerLine.point1 && lowerLine.point2) {
                    lowerLine.point1.moveTo([lower, 0]);
                    lowerLine.point2.moveTo([lower, lowerY]);
                }
                
                if (upperLine && upperLine.point1 && upperLine.point2) {
                    upperLine.point1.moveTo([upper, 0]);
                    upperLine.point2.moveTo([upper, upperY]);
                }
                
                // The riemannsum element automatically updates with parameter changes
            });

            // Apply dark theme to dropdown if needed
            if (integrationGraph.board.currentTheme === 'dark') {
                typesContainer.style.backgroundColor = 'rgba(30, 39, 46, 0.85)';
                typesContainer.style.color = '#ecf0f1';
                typeSelect.style.backgroundColor = '#34495e';
                typeSelect.style.color = '#ecf0f1';
                typeSelect.style.border = '1px solid #2c3e50';
            }

            
            // 8. Triangle Geometry
            // Find this section in the JavaScript portion of your HTML and REPLACE it completely:
            // 8. Triangle Geometry - Light Theme Implementation
            console.log("Initializing light theme triangle geometry implementation");

            // Get the container
            const triangleContainer = document.getElementById('triangle-container');

            // Create board container div if not exists
            let triangleBoardDiv = triangleContainer.querySelector('.jxgbox');
            if (!triangleBoardDiv) {
                triangleBoardDiv = document.createElement('div');
                triangleBoardDiv.id = 'triangle-jxgbox';
                triangleBoardDiv.className = 'jxgbox';
                triangleContainer.appendChild(triangleBoardDiv);
            }

            // Create title
            const triangleTitle = document.createElement('h3');
            triangleTitle.className = 'graph-title';
            triangleTitle.textContent = 'Interactive Triangle Properties';
            triangleContainer.insertBefore(triangleTitle, triangleContainer.firstChild);

            // Create controls
            const triangleControls = document.createElement('div');
            triangleControls.className = 'controls';
            triangleControls.innerHTML = `
                <button class="control-btn" id="triangle-lengths">Toggle Lengths</button>
                <button class="control-btn" id="triangle-angles">Toggle Angles</button>
                <button class="control-btn" id="triangle-circle">Toggle Circumcircle</button>
                <button class="control-btn" id="triangle-orthocenter">Toggle Orthocenter</button>
            `;
            triangleContainer.insertBefore(triangleControls, triangleBoardDiv);

            // Create info box - using light theme
            const triangleInfoBox = document.createElement('div');
            triangleInfoBox.className = 'info-box'; // Removed dark-theme class
            triangleInfoBox.style.top = '105px';
            triangleInfoBox.style.left = '20px';
            triangleInfoBox.style.backgroundColor = 'rgba(255, 255, 255, 0.9)'; // Light background
            triangleInfoBox.style.color = '#2d3748'; // Dark text
            triangleInfoBox.innerHTML = '<div><strong>Triangle Properties</strong></div><div id="triangle-info-content"></div>';
            triangleContainer.appendChild(triangleInfoBox);

            // Initialize board
            const triangleBoard = JXG.JSXGraph.initBoard('triangle-jxgbox', {
                boundingbox: [-5, 5, 5, -5],
                axis: false,
                grid: false,
                showNavigation: false,
                keepAspectRatio: true,
                showCopyright: false
            });

            // Set light background
            triangleBoard.containerObj.style.backgroundColor = '#ffffff';

            // Create triangle vertices
            const A = triangleBoard.create('point', [-3, -1], {
                name: 'A', 
                size: 4,
                fillColor: '#e74c3c',
                strokeColor: '#ffffff',
                withLabel: true
            });

            const B = triangleBoard.create('point', [3, -1], {
                name: 'B',
                size: 4,
                fillColor: '#3498db',
                strokeColor: '#ffffff',
                withLabel: true
            });

            const C = triangleBoard.create('point', [0, 3], {
                name: 'C',
                size: 4,
                fillColor: '#2ecc71',
                strokeColor: '#ffffff',
                withLabel: true
            });

            // Create the triangle
            const triangle = triangleBoard.create('polygon', [A, B, C], {
                borders: {
                    strokeWidth: 2,
                    strokeColor: '#34495e' // Darker border for light theme
                },
                fillColor: '#ecf0f1', // Light fill for light theme
                fillOpacity: 0.3
            });

            // Helper functions
            function distance(p1, p2) {
                return Math.sqrt(Math.pow(p2.X() - p1.X(), 2) + Math.pow(p2.Y() - p1.Y(), 2));
            }

            function calculateAngle(p1, p2, p3) {
                const a = distance(p2, p3);
                const b = distance(p1, p3);
                const c = distance(p1, p2);
                
                // Law of cosines
                let cosC = (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b);
                
                // Handle floating point errors
                if (cosC > 1) cosC = 1;
                if (cosC < -1) cosC = -1;
                
                return Math.acos(cosC) * (180 / Math.PI);
            }

            function calculateArea() {
                // Area using cross product
                const ax = A.X(), ay = A.Y();
                const bx = B.X(), by = B.Y();
                const cx = C.X(), cy = C.Y();
                
                return 0.5 * Math.abs((bx - ax) * (cy - ay) - (cx - ax) * (by - ay));
            }

            // Update info content function
            function updateTriangleInfo() {
                const angleA = calculateAngle(B, A, C).toFixed(1);
                const angleB = calculateAngle(A, B, C).toFixed(1);
                const angleC = calculateAngle(A, C, B).toFixed(1);
                const area = calculateArea().toFixed(2);
                const perimeter = (
                    distance(A, B) + 
                    distance(B, C) + 
                    distance(C, A)
                ).toFixed(2);
                
                const infoContent = document.getElementById('triangle-info-content');
                if (infoContent) {
                    infoContent.innerHTML = `
                        <div>Area: ${area}</div>
                        <div>Perimeter: ${perimeter}</div>
                        <div>Angles: A=${angleA}°, B=${angleB}°, C=${angleC}°</div>
                        <div>Sum: ${(parseFloat(angleA) + parseFloat(angleB) + parseFloat(angleC)).toFixed(1)}°</div>
                    `;
                }
            }

            // Initial info update
            updateTriangleInfo();

            // Update info on point moves
            A.on('drag', updateTriangleInfo);
            B.on('drag', updateTriangleInfo);
            C.on('drag', updateTriangleInfo);

            // Create side length labels (initially hidden)
            const sideAB = triangleBoard.create('text', [
                function() { return (A.X() + B.X()) / 2; },
                function() { return (A.Y() + B.Y()) / 2; },
                function() { return 'c = ' + distance(A, B).toFixed(2); }
            ], {visible: false, fontSize: 14, color: '#2d3748'}); // Dark text for light theme

            const sideBC = triangleBoard.create('text', [
                function() { return (B.X() + C.X()) / 2; },
                function() { return (B.Y() + C.Y()) / 2; },
                function() { return 'a = ' + distance(B, C).toFixed(2); }
            ], {visible: false, fontSize: 14, color: '#2d3748'}); // Dark text for light theme

            const sideCA = triangleBoard.create('text', [
                function() { return (C.X() + A.X()) / 2; },
                function() { return (C.Y() + A.Y()) / 2; },
                function() { return 'b = ' + distance(C, A).toFixed(2); }
            ], {visible: false, fontSize: 14, color: '#2d3748'}); // Dark text for light theme

            // Create angle arcs (initially hidden)
            const arcA = triangleBoard.create('angle', [B, A, C], {
                radius: 0.7,
                fillColor: '#e74c3c',
                fillOpacity: 0.3,
                strokeColor: '#e74c3c',
                strokeWidth: 1,
                visible: false
            });

            const arcB = triangleBoard.create('angle', [A, B, C], {
                radius: 0.7,
                fillColor: '#3498db',
                fillOpacity: 0.3,
                strokeColor: '#3498db',
                strokeWidth: 1,
                visible: false
            });

            const arcC = triangleBoard.create('angle', [A, C, B], {
                radius: 0.7,
                fillColor: '#2ecc71',
                fillOpacity: 0.3,
                strokeColor: '#2ecc71',
                strokeWidth: 1,
                visible: false
            });

            // Circumcircle (initially hidden)
            const circumcircle = triangleBoard.create('circumcircle', [A, B, C], {
                strokeWidth: 1,
                strokeColor: '#9b59b6',
                dash: 2,
                visible: false
            });

            const circumcenter = triangleBoard.create('circumcirclemidpoint', [A, B, C], {
                name: 'O',
                size: 3,
                color: '#9b59b6',
                visible: false
            });

            // Orthocenter construction (initially hidden)
            const altitudeA = triangleBoard.create('perpendicular', [triangle.borders[0], A], {
                strokeWidth: 1,
                strokeColor: '#e74c3c',
                dash: 2,
                visible: false
            });

            const altitudeB = triangleBoard.create('perpendicular', [triangle.borders[1], B], {
                strokeWidth: 1,
                strokeColor: '#3498db',
                dash: 2,
                visible: false
            });

            const altitudeC = triangleBoard.create('perpendicular', [triangle.borders[2], C], {
                strokeWidth: 1,
                strokeColor: '#2ecc71',
                dash: 2,
                visible: false
            });

            const orthocenter = triangleBoard.create('intersection', [altitudeA, altitudeB, 0], {
                name: 'H',
                size: 3,
                color: '#e67e22',
                visible: false
            });

            // Add button event listeners
            setTimeout(function() {
                const lengthsBtn = document.getElementById('triangle-lengths');
                const anglesBtn = document.getElementById('triangle-angles');
                const circleBtn = document.getElementById('triangle-circle');
                const orthocenterBtn = document.getElementById('triangle-orthocenter');
                
                if (lengthsBtn) {
                    lengthsBtn.addEventListener('click', function() {
                        const visible = !sideAB.getAttribute('visible');
                        sideAB.setAttribute({visible: visible});
                        sideBC.setAttribute({visible: visible});
                        sideCA.setAttribute({visible: visible});
                    });
                }
                
                if (anglesBtn) {
                    anglesBtn.addEventListener('click', function() {
                        const visible = !arcA.getAttribute('visible');
                        arcA.setAttribute({visible: visible});
                        arcB.setAttribute({visible: visible});
                        arcC.setAttribute({visible: visible});
                    });
                }
                
                if (circleBtn) {
                    circleBtn.addEventListener('click', function() {
                        const visible = !circumcircle.getAttribute('visible');
                        circumcircle.setAttribute({visible: visible});
                        circumcenter.setAttribute({visible: visible});
                    });
                }
                
                if (orthocenterBtn) {
                    orthocenterBtn.addEventListener('click', function() {
                        const visible = !altitudeA.getAttribute('visible');
                        altitudeA.setAttribute({visible: visible});
                        altitudeB.setAttribute({visible: visible});
                        altitudeC.setAttribute({visible: visible});
                        orthocenter.setAttribute({visible: visible});
                    });
                }
            }, 500); // Short delay to make sure elements exist

            console.log("Light theme triangle geometry initialization complete");
            
            //----------------------------------------------
            // STATISTICS SECTION
            //----------------------------------------------
            
            // 9. Normal Distribution with Z-Score Highlighting
            console.log("Initializing improved normal distribution visualization");

            // Get the container
            const normalDistContainer = document.getElementById('normal-dist-container');

            // Create board container div if not exists
            let normalDistBoardDiv = normalDistContainer.querySelector('.jxgbox');
            if (!normalDistBoardDiv) {
                normalDistBoardDiv = document.createElement('div');
                normalDistBoardDiv.id = 'normal-dist-jxgbox';
                normalDistBoardDiv.className = 'jxgbox';
                normalDistContainer.appendChild(normalDistBoardDiv);
            }

            // Create title
            const normalDistTitle = document.createElement('h3');
            normalDistTitle.className = 'graph-title';
            normalDistTitle.textContent = 'Normal Distribution & Z-Scores';
            normalDistContainer.insertBefore(normalDistTitle, normalDistContainer.firstChild);

            // Create controls
            const normalDistControls = document.createElement('div');
            normalDistControls.className = 'controls';
            normalDistControls.innerHTML = `
                <button class="control-btn" id="normal-reset">Reset View</button>
                <button class="control-btn" id="normal-highlight-z1">Highlight ±1σ</button>
                <button class="control-btn" id="normal-highlight-z2">Highlight ±2σ</button>
                <button class="control-btn" id="normal-highlight-z3">Highlight ±3σ</button>
                <button class="control-btn" id="normal-custom-z">Custom Z-Score</button>
            `;
            normalDistContainer.insertBefore(normalDistControls, normalDistBoardDiv);

            // Create slider container
            const normalDistSliderContainer = document.createElement('div');
            normalDistSliderContainer.className = 'slider-container';
            normalDistContainer.appendChild(normalDistSliderContainer);

            // Create info box
            const normalDistInfoBox = document.createElement('div');
            normalDistInfoBox.className = 'info-box';
            normalDistInfoBox.style.top = '65px';
            normalDistInfoBox.style.left = '20px';
            normalDistInfoBox.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            normalDistInfoBox.innerHTML = `
                <div><strong>Normal Distribution</strong></div>
                <div>f(x) = (1/(σ√2π))e<sup>-(x-μ)²/2σ²</sup></div>
                <div id="normal-dist-params"></div>
                <div id="normal-dist-area"></div>
            `;
            normalDistContainer.appendChild(normalDistInfoBox);

            // Custom Z-score input modal (initially hidden)
            const zScoreModal = document.createElement('div');
            zScoreModal.className = 'slider-container';
            zScoreModal.style.display = 'none';
            zScoreModal.style.position = 'absolute';
            zScoreModal.style.top = '50%';
            zScoreModal.style.left = '50%';
            zScoreModal.style.transform = 'translate(-50%, -50%)';
            zScoreModal.style.padding = '15px';
            zScoreModal.style.zIndex = '1000';
            zScoreModal.style.width = '250px';
            zScoreModal.style.boxShadow = '0 4px 10px rgba(0,0,0,0.2)';
            zScoreModal.innerHTML = `
                <div style="margin-bottom:10px"><strong>Custom Z-Score Range</strong></div>
                <div style="display:flex; align-items:center; margin-bottom:10px">
                    <label style="width:70px">From Z:</label>
                    <input type="number" id="z-from" value="-1" step="0.1" style="width:60px">
                </div>
                <div style="display:flex; align-items:center; margin-bottom:15px">
                    <label style="width:70px">To Z:</label>
                    <input type="number" id="z-to" value="1" step="0.1" style="width:60px">
                </div>
                <div style="display:flex; justify-content:flex-end; gap:10px">
                    <button id="z-cancel" class="control-btn">Cancel</button>
                    <button id="z-apply" class="control-btn">Apply</button>
                </div>
            `;
            normalDistContainer.appendChild(zScoreModal);

            // Initialize the board with a better bounding box and explicit zoom/pan options
            const normalDistBoard = JXG.JSXGraph.initBoard('normal-dist-jxgbox', {
                boundingbox: [-4, 0.5, 4, -0.05],
                axis: true,
                grid: true,
                showNavigation: true,
                showCopyright: false,
                pan: {
                    enabled: true,
                    needShift: false,
                    needTwoFingers: false
                },
                zoom: {
                    enabled: true,
                    wheel: true,
                    needShift: false,
                    pinch: true,
                    min: 0.1,
                    max: 10
                }
            });

            // Store original bounding box for reset
            normalDistBoard.originalBoundingBox = [-4, 0.5, 4, -0.05];

            // Parameters with default values
            let normalDistParams = {
                mu: 0,
                sigma: 0.5
            };

            // Current Z-score highlighting
            let currentHighlight = {
                active: false,
                fromZ: -1,
                toZ: 1
            };

            // Create the normal distribution curve
            function normalPDF(x, mu, sigma) {
                // Add safety checks
                if (sigma <= 0.01) sigma = 0.01; // Prevent division by zero or very small values
                
                return (1 / (sigma * Math.sqrt(2 * Math.PI))) * 
                    Math.exp(-Math.pow(x - mu, 2) / (2 * Math.pow(sigma, 2)));
            }

            // Create the main normal distribution function
            const normalCurve = normalDistBoard.create('functiongraph', [
                function(x) {
                    return normalPDF(x, normalDistParams.mu, normalDistParams.sigma);
                },
                -10, 10
            ], {
                strokeColor: '#3498db',
                strokeWidth: 3,
                highlight: false
            });

            // Create filled areas for standard deviations
            // First create base points
            const areaPoints = [];
            for (let i = 0; i <= 50; i++) {
                // Placeholder points - will be updated in update function
                areaPoints.push(normalDistBoard.create('point', [0, 0], {
                    visible: false,
                    fixed: true
                }));
            }

            // Create highlighted area polygon
            const highlightedArea = normalDistBoard.create('polygon', areaPoints, {
                fillColor: '#ffd700', // Gold color
                fillOpacity: 0.4,
                borders: {visible: false},
                visible: false
            });

            // Create axis lines (at y=0)
            normalDistBoard.create('line', [[-10, 0], [10, 0]], {
                strokeColor: '#95a5a6',
                strokeWidth: 1,
                highlight: false,
                fixed: true
            });

            // Create legends for standard deviations
            // Add markers for +/- 1, 2, 3 sigma
            const sigmaLines = [];
            for (let i = 1; i <= 3; i++) {
                // Line markers
                const minusSigmaLine = normalDistBoard.create('line', [
                    [function() { return normalDistParams.mu - i * normalDistParams.sigma; }, -0.1],
                    [function() { return normalDistParams.mu - i * normalDistParams.sigma; }, function() { 
                        return normalPDF(normalDistParams.mu - i * normalDistParams.sigma, normalDistParams.mu, normalDistParams.sigma) * 1.1;
                    }]
                ], {
                    strokeColor: i === 1 ? '#3498db' : (i === 2 ? '#2ecc71' : '#e74c3c'),
                    strokeWidth: 1,
                    dash: 2,
                    highlight: false
                });
                
                const plusSigmaLine = normalDistBoard.create('line', [
                    [function() { return normalDistParams.mu + i * normalDistParams.sigma; }, -0.1],
                    [function() { return normalDistParams.mu + i * normalDistParams.sigma; }, function() { 
                        return normalPDF(normalDistParams.mu + i * normalDistParams.sigma, normalDistParams.mu, normalDistParams.sigma) * 1.1;
                    }]
                ], {
                    strokeColor: i === 1 ? '#3498db' : (i === 2 ? '#2ecc71' : '#e74c3c'),
                    strokeWidth: 1,
                    dash: 2,
                    highlight: false
                });
                
                sigmaLines.push(minusSigmaLine, plusSigmaLine);
                
                // Labels
                const sigmaText = normalDistBoard.create('text', [
                    function() { return normalDistParams.mu + i * normalDistParams.sigma + 0.1; },
                    0.03,
                    function() { return (i === 1 ? '+1σ' : (i === 2 ? '+2σ' : '+3σ')); }
                ], {
                    fontSize: 12,
                    color: i === 1 ? '#3498db' : (i === 2 ? '#2ecc71' : '#e74c3c'),
                    anchorX: 'left'
                });
                
                const minusSigmaText = normalDistBoard.create('text', [
                    function() { return normalDistParams.mu - i * normalDistParams.sigma - 0.1; },
                    0.03,
                    function() { return (i === 1 ? '-1σ' : (i === 2 ? '-2σ' : '-3σ')); }
                ], {
                    fontSize: 12,
                    color: i === 1 ? '#3498db' : (i === 2 ? '#2ecc71' : '#e74c3c'),
                    anchorX: 'right'
                });
            }

            // Add info legends
            const legendBox = normalDistBoard.create('text', [
                1.9, 0.45,
                function() {
                    return '68% within ±1σ: ' + (normalDistParams.mu - normalDistParams.sigma).toFixed(2) + 
                        ' to ' + (normalDistParams.mu + normalDistParams.sigma).toFixed(2);
                }
            ], {
                fontSize: 12,
                color: '#3498db',
                highlight: false,
                fixed: true
            });

            const legend95 = normalDistBoard.create('text', [
                1.9, 0.41,
                function() {
                    return '95% within ±2σ: ' + (normalDistParams.mu - 2 * normalDistParams.sigma).toFixed(2) + 
                        ' to ' + (normalDistParams.mu + 2 * normalDistParams.sigma).toFixed(2);
                }
            ], {
                fontSize: 12,
                color: '#2ecc71',
                highlight: false,
                fixed: true
            });

            const legend997 = normalDistBoard.create('text', [
                1.9, 0.37,
                function() {
                    return '99.7% within ±3σ: ' + (normalDistParams.mu - 3 * normalDistParams.sigma).toFixed(2) + 
                        ' to ' + (normalDistParams.mu + 3 * normalDistParams.sigma).toFixed(2);
                }
            ], {
                fontSize: 12,
                color: '#e74c3c',
                highlight: false,
                fixed: true
            });

            // Function to create parameter sliders
            function createParameterSliders() {
                normalDistSliderContainer.innerHTML = '';
                
                // Mean slider
                const muRow = document.createElement('div');
                muRow.className = 'slider-row';
                
                const muLabel = document.createElement('div');
                muLabel.className = 'slider-label';
                muLabel.textContent = 'μ:';
                
                const muSlider = document.createElement('input');
                muSlider.type = 'range';
                muSlider.className = 'slider-input';
                muSlider.min = -3;
                muSlider.max = 3;
                muSlider.step = 0.1;
                muSlider.value = normalDistParams.mu;
                
                const muValue = document.createElement('div');
                muValue.className = 'slider-value';
                muValue.textContent = normalDistParams.mu.toFixed(1);
                
                muSlider.addEventListener('input', function() {
                    normalDistParams.mu = parseFloat(this.value);
                    muValue.textContent = normalDistParams.mu.toFixed(1);
                    updateVisualization();
                });
                
                muRow.appendChild(muLabel);
                muRow.appendChild(muSlider);
                muRow.appendChild(muValue);
                normalDistSliderContainer.appendChild(muRow);
                
                // Standard deviation slider
                const sigmaRow = document.createElement('div');
                sigmaRow.className = 'slider-row';
                
                const sigmaLabel = document.createElement('div');
                sigmaLabel.className = 'slider-label';
                sigmaLabel.textContent = 'σ:';
                
                const sigmaSlider = document.createElement('input');
                sigmaSlider.type = 'range';
                sigmaSlider.className = 'slider-input';
                sigmaSlider.min = 0.1;
                sigmaSlider.max = 1.5;
                sigmaSlider.step = 0.05;
                sigmaSlider.value = normalDistParams.sigma;
                
                const sigmaValue = document.createElement('div');
                sigmaValue.className = 'slider-value';
                sigmaValue.textContent = normalDistParams.sigma.toFixed(2);
                
                sigmaSlider.addEventListener('input', function() {
                    normalDistParams.sigma = parseFloat(this.value);
                    sigmaValue.textContent = normalDistParams.sigma.toFixed(2);
                    updateVisualization();
                });
                
                sigmaRow.appendChild(sigmaLabel);
                sigmaRow.appendChild(sigmaSlider);
                sigmaRow.appendChild(sigmaValue);
                normalDistSliderContainer.appendChild(sigmaRow);
            }

            // Function to update parameter display in info box
            function updateParamDisplay() {
                const paramsDiv = document.getElementById('normal-dist-params');
                if (paramsDiv) {
                    paramsDiv.innerHTML = `
                        <div>Mean (μ): ${normalDistParams.mu.toFixed(2)}</div>
                        <div>Standard Deviation (σ): ${normalDistParams.sigma.toFixed(2)}</div>
                    `;
                }
                
                // Update area info if highlighting is active
                updateAreaInfo();
            }

            // Function to calculate area under normal curve (Z-table values)
            function calculateNormalArea(lowerZ, upperZ) {
                // Using approximation based on error function (erf)
                function erf(x) {
                    // Approximation of error function
                    // Constants
                    const a1 =  0.254829592;
                    const a2 = -0.284496736;
                    const a3 =  1.421413741;
                    const a4 = -1.453152027;
                    const a5 =  1.061405429;
                    const p  =  0.3275911;
                    
                    // Save the sign of x
                    const sign = x < 0 ? -1 : 1;
                    x = Math.abs(x);
                    
                    // Formula 7.1.26 from Abramowitz and Stegun
                    const t = 1.0 / (1.0 + p * x);
                    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                    
                    return sign * y;
                }
                
                // Calculate cumulative distribution function
                function normalCDF(z) {
                    return 0.5 * (1 + erf(z / Math.sqrt(2)));
                }
                
                // Calculate area between lowerZ and upperZ
                return normalCDF(upperZ) - normalCDF(lowerZ);
            }

            // Function to update area info in the info box
            function updateAreaInfo() {
                const areaDiv = document.getElementById('normal-dist-area');
                if (!areaDiv) return;
                
                if (currentHighlight.active) {
                    const lowerX = normalDistParams.mu + currentHighlight.fromZ * normalDistParams.sigma;
                    const upperX = normalDistParams.mu + currentHighlight.toZ * normalDistParams.sigma;
                    const area = calculateNormalArea(currentHighlight.fromZ, currentHighlight.toZ);
                    const percentage = (area * 100).toFixed(2);
                    
                    areaDiv.innerHTML = `
                        <div style="margin-top:10px; font-weight:bold;">Highlighted Area:</div>
                        <div>Z-score range: ${currentHighlight.fromZ.toFixed(1)} to ${currentHighlight.toZ.toFixed(1)}</div>
                        <div>X-value range: ${lowerX.toFixed(2)} to ${upperX.toFixed(2)}</div>
                        <div>Area: ${percentage}% of total</div>
                    `;
                } else {
                    areaDiv.innerHTML = '';
                }
            }

            // Function to update highlighted area
            function updateHighlightedArea() {
                if (!currentHighlight.active) {
                    highlightedArea.setAttribute({visible: false});
                    return;
                }
                
                // Calculate x-values from z-scores
                const lowerX = normalDistParams.mu + currentHighlight.fromZ * normalDistParams.sigma;
                const upperX = normalDistParams.mu + currentHighlight.toZ * normalDistParams.sigma;
                
                // Number of interpolation points to create a smooth curve
                const numPoints = 40; 
                const step = (upperX - lowerX) / numPoints;
                
                // Create points for the polygon
                const points = [];
                
                // Add bottom-left point
                points.push([lowerX, 0]);
                
                // Add curve points
                for (let i = 0; i <= numPoints; i++) {
                    const x = lowerX + i * step;
                    const y = normalPDF(x, normalDistParams.mu, normalDistParams.sigma);
                    points.push([x, y]);
                }
                
                // Add bottom-right point to close the polygon
                points.push([upperX, 0]);
                
                // Update the polygon points
                for (let i = 0; i < points.length; i++) {
                    if (i < areaPoints.length) {
                        areaPoints[i].setPosition(JXG.COORDS_BY_USER, points[i]);
                    }
                }
                
                // Make the polygon visible
                highlightedArea.setAttribute({visible: true});
                
                // Update the board
                normalDistBoard.update();
            }

            // Main function to update visualization
            function updateVisualization() {
                // Update curve and other elements automatically through the board update
                normalDistBoard.update();
                
                // Update highlighted area if active
                updateHighlightedArea();
                
                // Update parameter display
                updateParamDisplay();
            }

            // Create the parameter sliders
            createParameterSliders();

            // Initial update
            updateParamDisplay();

            // Reset view function
            function resetView() {
                normalDistBoard.setBoundingBox(normalDistBoard.originalBoundingBox);
                normalDistParams.mu = 0;
                normalDistParams.sigma = 0.5;
                
                // Update sliders
                const muSlider = normalDistSliderContainer.querySelector('input:nth-child(2)');
                const sigmaSlider = normalDistSliderContainer.querySelector('input:nth-of-type(2)');
                const muValue = normalDistSliderContainer.querySelector('.slider-value');
                const sigmaValue = normalDistSliderContainer.querySelectorAll('.slider-value')[1];
                
                if (muSlider) muSlider.value = normalDistParams.mu;
                if (sigmaSlider) sigmaSlider.value = normalDistParams.sigma;
                if (muValue) muValue.textContent = normalDistParams.mu.toFixed(1);
                if (sigmaValue) sigmaValue.textContent = normalDistParams.sigma.toFixed(2);
                
                // Clear highlighting
                currentHighlight.active = false;
                
                // Update visualization
                updateVisualization();
            }

            // Highlight Z-score function
            function highlightZScore(fromZ, toZ) {
                currentHighlight.active = true;
                currentHighlight.fromZ = fromZ;
                currentHighlight.toZ = toZ;
                updateHighlightedArea();
                updateAreaInfo();
            }

            // Add button event listeners
            setTimeout(function() {
                const resetBtn = document.getElementById('normal-reset');
                const highlightZ1Btn = document.getElementById('normal-highlight-z1');
                const highlightZ2Btn = document.getElementById('normal-highlight-z2');
                const highlightZ3Btn = document.getElementById('normal-highlight-z3');
                const customZBtn = document.getElementById('normal-custom-z');
                const zApplyBtn = document.getElementById('z-apply');
                const zCancelBtn = document.getElementById('z-cancel');
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', resetView);
                }
                
                if (highlightZ1Btn) {
                    highlightZ1Btn.addEventListener('click', function() {
                        highlightZScore(-1, 1);
                    });
                }
                
                if (highlightZ2Btn) {
                    highlightZ2Btn.addEventListener('click', function() {
                        highlightZScore(-2, 2);
                    });
                }
                
                if (highlightZ3Btn) {
                    highlightZ3Btn.addEventListener('click', function() {
                        highlightZScore(-3, 3);
                    });
                }
                
                if (customZBtn) {
                    customZBtn.addEventListener('click', function() {
                        zScoreModal.style.display = 'block';
                    });
                }
                
                if (zApplyBtn) {
                    zApplyBtn.addEventListener('click', function() {
                        const fromZ = parseFloat(document.getElementById('z-from').value);
                        const toZ = parseFloat(document.getElementById('z-to').value);
                        
                        if (!isNaN(fromZ) && !isNaN(toZ) && fromZ < toZ) {
                            highlightZScore(fromZ, toZ);
                            zScoreModal.style.display = 'none';
                        } else {
                            alert('Please enter valid Z-score values where "From" is less than "To"');
                        }
                    });
                }
                
                if (zCancelBtn) {
                    zCancelBtn.addEventListener('click', function() {
                        zScoreModal.style.display = 'none';
                    });
                }
            }, 500); // Short delay to make sure elements exist

            console.log("Normal distribution visualization initialized");
            
            // 10. Linear Regression
            const regressionGraph = MathVisualizer.createGraphFromDescription('regression-container', {
                boundingBox: [-1, 10, 10, -1],
                theme: 'dark',
                useSequentialColors: true,
                
                infoBox: {
                    title: "Linear Regression",
                    lines: [
                        {text: "y = mx + b", dynamic: false},
                        {text: "Slope (m): ${m}", dynamic: true},
                        {text: "y-intercept (b): ${b}", dynamic: true},
                        {text: "Correlation: ${correlation}", dynamic: true},
                        {text: "SSE: ${sse}", dynamic: true}
                    ],
                    position: {top: 65, left: 20}
                },
                
                parametrizedFunctions: [
                    {
                        // Dummy expression to enable parameters
                        expression: '0',
                        title: 'Linear Regression',
                        parameters: {
                            m: { min: -2, max: 2, value: 0.8, step: 0.05 },
                            b: { min: -3, max: 10, value: 1, step: 0.1 },
                            correlation: { min: -1, max: 1, value: 0.7, step: 0.01 },
                            sse: { min: 0, max: 100, value: 5.2, step: 0.1 }
                        }
                    }
                ],
                
                elements: [
                    // Regression line
                    {
                        type: 'line',
                        data: [[0, 1], [1, 1.8]],
                        properties: { 
                            strokeColor: '#3498db',
                            strokeWidth: 3
                        }
                    }
                ]
            });
            
            // Add data points
            const dataPoints = [
                [1, 2],
                [2, 3.5],
                [3, 3.2],
                [4, 4.8],
                [5, 4.3],
                [6, 5.5],
                [7, 6.2],
                [8, 7.1]
            ];
            
            // Create data points
            const jsxPoints = [];
            for (let i = 0; i < dataPoints.length; i++) {
                const point = regressionGraph.board.create('point', dataPoints[i], {
                    size: 4,
                    fillColor: '#e74c3c',
                    strokeColor: '#ffffff',
                    name: ''
                });
                jsxPoints.push(point);
            }
            
            // Calculate error lines
            const errorLines = [];
            for (let i = 0; i < dataPoints.length; i++) {
                const line = regressionGraph.board.create('segment', 
                    [dataPoints[i], [dataPoints[i][0], 0]], 
                    {strokeColor: '#95a5a6', strokeWidth: 1, dash: 2}
                );
                errorLines.push(line);
            }
            
            // Update regression line and error markers when parameters change
            regressionGraph.board.on('update', function() {
                // Get current parameters
                const m = regressionGraph.parameterValues.m;
                const b = regressionGraph.parameterValues.b;
                
                // Update regression line
                if (regressionGraph.board.objects && regressionGraph.board.objects.length >= 1) {
                    const regressionLine = regressionGraph.board.objects[0];
                    if (regressionLine && regressionLine.point1 && regressionLine.point2) {
                        // Use general form: ax + by + c = 0
                        // For y = mx + b, that's: -mx + y - b = 0
                        // So a = -m, b = 1, c = -b
                        const a = -m;
                        const bCoef = 1;
                        const c = -b;
                        
                        regressionLine.setPosition(JXG.COORDS_BY_USER, [a, bCoef, c]);
                    }
                }
                
                // Update error lines
                for (let i = 0; i < jsxPoints.length; i++) {
                    const point = jsxPoints[i];
                    const errorLine = errorLines[i];
                    
                    if (point && point.X && point.Y && errorLine && errorLine.point2) {
                        const x = point.X();
                        const predictedY = m * x + b;
                        errorLine.point2.moveTo([x, predictedY]);
                    }
                }
                
                // Calculate SSE (sum of squared errors)
                let sse = 0;
                for (let i = 0; i < dataPoints.length; i++) {
                    const x = dataPoints[i][0];
                    const y = dataPoints[i][1];
                    const predictedY = m * x + b;
                    const error = y - predictedY;
                    sse += error * error;
                }
                
                // Update the SSE parameter for display
                regressionGraph.parameterValues.sse = Math.round(sse * 100) / 100;
                
                // Calculate correlation (this is simplified and not statistically accurate)
                // In a real implementation, this would be calculated from the data points
                // But for the demo, we'll adjust it based on SSE
                const correlation = Math.max(-1, Math.min(1, 1 - (sse / 20)));
                regressionGraph.parameterValues.correlation = Math.round(correlation * 100) / 100;
            });
            
            console.log("All visualizations initialized successfully!");
        });

        








            // Probability and Histogram Demonstration


            // Get the container
            const probabilityContainer = document.getElementById('probability-container');
            if (!probabilityContainer) {
                console.error("Probability container not found! Please add the HTML structure first.");
            } else {
                // Create board container div if not exists
                let probabilityBoardDiv = probabilityContainer.querySelector('.jxgbox');
                if (!probabilityBoardDiv) {
                    probabilityBoardDiv = document.createElement('div');
                    probabilityBoardDiv.id = 'probability-jxgbox';
                    probabilityBoardDiv.className = 'jxgbox';
                    probabilityContainer.appendChild(probabilityBoardDiv);
                }

                // Create title
                const probabilityTitle = document.createElement('h3');
                probabilityTitle.className = 'graph-title';
                probabilityTitle.textContent = 'Interactive Probability & Histogram';
                probabilityContainer.insertBefore(probabilityTitle, probabilityContainer.firstChild);

                // Create distribution selector
                const distributionSelector = document.createElement('div');
                distributionSelector.className = 'controls';
                distributionSelector.innerHTML = `
                    <select id="distribution-select" class="control-btn">
                        <option value="binomial">Binomial Distribution</option>
                        <option value="normal">Normal Distribution</option>
                        <option value="poisson">Poisson Distribution</option>
                        <option value="uniform">Uniform Distribution</option>
                    </select>
                    <button class="control-btn" id="probability-generate">Generate Data</button>
                    <button class="control-btn" id="probability-calculate">Calculate P(a≤X≤b)</button>
                    <button class="control-btn" id="probability-overlay">Toggle Distribution</button>
                `;
                probabilityContainer.insertBefore(distributionSelector, probabilityBoardDiv);
                
                // Create sample size control
                const sampleSizeControl = document.createElement('div');
                sampleSizeControl.className = 'controls';
                sampleSizeControl.style.marginTop = '5px';
                sampleSizeControl.innerHTML = `
                    <span style="margin-right: 10px;">Sample Size:</span>
                    <input type="number" id="sample-size-input" min="50" max="5000" step="50" value="500" style="width: 80px; margin-right: 10px;">
                    <input type="range" id="sample-size-slider" min="50" max="5000" step="50" value="500" style="width: 200px; vertical-align: middle;">
                `;
                probabilityContainer.insertBefore(sampleSizeControl, probabilityBoardDiv);

                // Create parameter sliders container
                const probabilitySliders = document.createElement('div');
                probabilitySliders.className = 'slider-container';
                probabilitySliders.id = 'probability-sliders';
                probabilityContainer.appendChild(probabilitySliders);

                // Create range selection modal (initially hidden)
                const rangeModal = document.createElement('div');
                rangeModal.className = 'slider-container';
                rangeModal.style.display = 'none';
                rangeModal.style.position = 'absolute';
                rangeModal.style.top = '50%';
                rangeModal.style.left = '50%';
                rangeModal.style.transform = 'translate(-50%, -50%)';
                rangeModal.style.padding = '15px';
                rangeModal.style.zIndex = '1000';
                rangeModal.style.width = '250px';
                rangeModal.style.boxShadow = '0 4px 10px rgba(0,0,0,0.2)';
                rangeModal.innerHTML = `
                    <div style="margin-bottom:10px"><strong>Calculate Probability</strong></div>
                    <div style="display:flex; align-items:center; margin-bottom:10px">
                        <label style="width:70px">From:</label>
                        <input type="number" id="prob-from" value="3" step="1" style="width:60px">
                    </div>
                    <div style="display:flex; align-items:center; margin-bottom:15px">
                        <label style="width:70px">To:</label>
                        <input type="number" id="prob-to" value="7" step="1" style="width:60px">
                    </div>
                    <div style="display:flex; justify-content:flex-end; gap:10px">
                        <button id="prob-cancel" class="control-btn">Cancel</button>
                        <button id="prob-apply" class="control-btn">Calculate</button>
                    </div>
                `;
                probabilityContainer.appendChild(rangeModal);

                // Create info box
                const probabilityInfoBox = document.createElement('div');
                probabilityInfoBox.className = 'info-box';
                probabilityInfoBox.style.top = '65px';
                probabilityInfoBox.style.left = '20px';
                probabilityInfoBox.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
                probabilityInfoBox.innerHTML = `
                    <div><strong id="distribution-title">Binomial Distribution</strong></div>
                    <div id="distribution-formula">P(X=k) = (n choose k) p^k (1-p)^(n-k)</div>
                    <div id="distribution-params"></div>
                    <div id="sample-stats"></div>
                    <div id="probability-result"></div>
                `;
                probabilityContainer.appendChild(probabilityInfoBox);

                // Initialize the board
                const probabilityBoard = JXG.JSXGraph.initBoard('probability-jxgbox', {
                    boundingbox: [-1, 12, 21, -2],
                    axis: true,
                    grid: true,
                    showNavigation: true,
                    showCopyright: false,
                    pan: {
                        enabled: true,
                        needShift: false
                    },
                    zoom: {
                        enabled: true,
                        wheel: true,
                        needShift: false
                    }
                });

                // State variables
                let currentDistribution = 'binomial';
                let distributionParams = {
                    binomial: { n: 20, p: 0.5 },
                    normal: { mean: 10, stddev: 2 },
                    poisson: { lambda: 5 },
                    uniform: { min: 1, max: 15 }
                };
                let sampleData = [];
                let sampleSize = 500; // Initial sample size
                let histogramBars = [];
                let overlayPlot = null;
                let probabilityHighlight = null;
                let highlightedRange = { min: 0, max: 0 };
                let showDistributionOverlay = false;

                // Formula display templates
                const formulas = {
                    binomial: "P(X=k) = (n choose k) p^k (1-p)^(n-k)",
                    normal: "f(x) = (1/(σ√2π))e^(-(x-μ)²/2σ²)",
                    poisson: "P(X=k) = (λ^k e^(-λ))/k!",
                    uniform: "f(x) = 1/(b-a) for a≤x≤b, 0 otherwise"
                };

                // Generate random data based on the selected distribution
                function generateData() {
                    sampleData = [];
                    const params = distributionParams[currentDistribution];
                    
                    switch (currentDistribution) {
                        case 'binomial':
                            for (let i = 0; i < sampleSize; i++) {
                                let successes = 0;
                                for (let j = 0; j < params.n; j++) {
                                    if (Math.random() < params.p) successes++;
                                }
                                sampleData.push(successes);
                            }
                            break;
                            
                        case 'normal':
                            // Box-Muller transform for normal distribution
                            for (let i = 0; i < sampleSize; i++) {
                                const u1 = Math.random();
                                const u2 = Math.random();
                                const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                                const value = params.mean + params.stddev * z;
                                // Round to nearest integer for histogram consistency
                                sampleData.push(Math.round(value));
                            }
                            break;
                            
                        case 'poisson':
                            for (let i = 0; i < sampleSize; i++) {
                                // Knuth's algorithm for Poisson distribution
                                const L = Math.exp(-params.lambda);
                                let k = 0;
                                let p = 1;
                                
                                do {
                                    k++;
                                    p *= Math.random();
                                } while (p > L);
                                
                                sampleData.push(k - 1);
                            }
                            break;
                            
                        case 'uniform':
                            for (let i = 0; i < sampleSize; i++) {
                                // Uniform distribution between min and max
                                const range = params.max - params.min;
                                const value = Math.floor(Math.random() * (range + 1)) + params.min;
                                sampleData.push(value);
                            }
                            break;
                    }
                    
                    updateHistogram();
                    updateSampleStats();
                }

                // Calculate the frequency of each value in the dataset
                function calculateFrequencies() {
                    const frequencies = {};
                    
                    // Find min and max values in the data
                    let minValue = Math.min(...sampleData);
                    let maxValue = Math.max(...sampleData);
                    
                    // Initialize frequencies for all values in range
                    for (let i = minValue; i <= maxValue; i++) {
                        frequencies[i] = 0;
                    }
                    
                    // Count frequencies
                    sampleData.forEach(value => {
                        frequencies[value]++;
                    });
                    
                    return {
                        frequencies,
                        minValue,
                        maxValue
                    };
                }

                // Create or update the histogram
                function updateHistogram() {
                    // Clear existing bars
                    histogramBars.forEach(bar => {
                        if (bar.length) {
                            bar.forEach(el => {
                                probabilityBoard.removeObject(el);
                            });
                        }
                    });
                    histogramBars = [];
                    
                    // Calculate frequencies
                    const { frequencies, minValue, maxValue } = calculateFrequencies();
                    
                    // Find the maximum frequency for scaling
                    const maxFreq = Math.max(...Object.values(frequencies));
                    
                    // Create bar for each value
                    for (let value = minValue; value <= maxValue; value++) {
                        const frequency = frequencies[value];
                        const barHeight = (frequency / sampleSize) * 10; // Scale to a reasonable height
                        
                        const barElements = [];
                        
                        // Create rectangle for bar
                        const bar = probabilityBoard.create('polygon', [
                            [value - 0.4, 0],
                            [value + 0.4, 0],
                            [value + 0.4, barHeight],
                            [value - 0.4, barHeight]
                        ], {
                            fillColor: '#3498db',
                            fillOpacity: 0.7,
                            borders: {
                                strokeWidth: 1,
                                strokeColor: '#2980b9'
                            },
                            vertices: {
                                visible: false
                            }
                        });
                        
                        // Add frequency label on top of bar if high enough
                        if (barHeight > 0.5) {
                            const label = probabilityBoard.create('text', [
                                value, 
                                barHeight + 0.2, 
                                frequency.toString()
                            ], {
                                anchorX: 'middle',
                                anchorY: 'bottom',
                                fontSize: 10
                            });
                            barElements.push(label);
                        }
                        
                        barElements.push(bar);
                        histogramBars.push(barElements);
                    }
                    
                    // Update the distribution overlay if visible
                    if (showDistributionOverlay) {
                        updateDistributionOverlay();
                    }
                    
                    // Update board view to fit the histogram
                    probabilityBoard.setBoundingBox([-1, maxFreq / sampleSize * 10 + 2, maxValue + 2, -2]);
                }

                // Calculate and display theoretical distribution overlay
                function updateDistributionOverlay() {
                    // Remove existing overlay
                    if (overlayPlot) {
                        probabilityBoard.removeObject(overlayPlot);
                        overlayPlot = null;
                    }
                    
                    const { minValue, maxValue } = calculateFrequencies();
                    const params = distributionParams[currentDistribution];
                    
                    // Calculate scaling factor based on histogram height
                    // We need to make the theoretical curve match the histogram scale
                    // Histogram bars are scaled as (frequency/sampleSize) * 10
                    const scalingFactor = 10; // This matches our histogram bar scaling
                    
                    // Create the distribution function based on the current distribution
                    let distributionFunction;
                    
                    switch (currentDistribution) {
                        case 'binomial':
                            distributionFunction = function(x) {
                                // Must be an integer in the valid range
                                if (x < 0 || x > params.n || x !== Math.floor(x)) {
                                    return 0;
                                }
                                
                                // Calculate binomial coefficient (n choose k)
                                const binomialCoeff = function(n, k) {
                                    let coeff = 1;
                                    for (let i = n - k + 1; i <= n; i++) {
                                        coeff *= i;
                                    }
                                    for (let i = 1; i <= k; i++) {
                                        coeff /= i;
                                    }
                                    return coeff;
                                };
                                
                                // Calculate probability
                                const coefficient = binomialCoeff(params.n, x);
                                const p = params.p;
                                const probability = coefficient * Math.pow(p, x) * Math.pow(1 - p, params.n - x);
                                
                                // Scale to match histogram height
                                return probability * scalingFactor;
                            };
                            break;
                            
                        case 'normal':
                            distributionFunction = function(x) {
                                // Normal PDF
                                const mean = params.mean;
                                const stddev = params.stddev;
                                
                                // Calculate normal PDF: (1/(σ√2π))e^(-(x-μ)²/2σ²)
                                const coefficient = 1 / (stddev * Math.sqrt(2 * Math.PI));
                                const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(stddev, 2));
                                const probability = coefficient * Math.exp(exponent);
                                
                                // For normal distribution, scale by sample size to match histogram
                                // We multiply by 1.0 because PMF for discrete approx of normal needs to account for bin width
                                return probability * scalingFactor * sampleSize * 1.0;
                            };
                            break;
                            
                        case 'poisson':
                            distributionFunction = function(x) {
                                // Must be a non-negative integer
                                if (x < 0 || x !== Math.floor(x)) {
                                    return 0;
                                }
                                
                                // Calculate Poisson PMF: (λ^k)(e^-λ)/k!
                                const lambda = params.lambda;
                                let probability = Math.exp(-lambda);
                                
                                // Calculate λ^k / k!
                                let factorial = 1;
                                for (let i = 1; i <= x; i++) {
                                    factorial *= i;
                                    probability *= lambda / i;
                                }
                                
                                // Scale to match histogram height
                                return probability * scalingFactor;
                            };
                            break;
                            
                        case 'uniform':
                            distributionFunction = function(x) {
                                // Check if x is in range
                                if (x < params.min || x > params.max || x !== Math.floor(x)) {
                                    return 0;
                                }
                                
                                // Calculate uniform PMF: 1/(max-min+1)
                                const probability = 1 / (params.max - params.min + 1);
                                
                                // Scale to match histogram height
                                return probability * scalingFactor;
                            };
                            break;
                    }
                    
                    // Create function plot
                    overlayPlot = probabilityBoard.create('functiongraph', [
                        distributionFunction,
                        minValue - 1, 
                        maxValue + 1
                    ], {
                        strokeColor: '#e74c3c',
                        strokeWidth: 3,
                        dash: 2
                    });
                }

                // Calculate and display statistics about the sample
                function updateSampleStats() {
                    if (sampleData.length === 0) return;
                    
                    // Calculate mean
                    const mean = sampleData.reduce((sum, value) => sum + value, 0) / sampleData.length;
                    
                    // Calculate variance and standard deviation
                    const variance = sampleData.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / sampleData.length;
                    const stdDev = Math.sqrt(variance);
                    
                    // Find min, max, and median
                    const sortedData = [...sampleData].sort((a, b) => a - b);
                    const min = sortedData[0];
                    const max = sortedData[sortedData.length - 1];
                    const median = sortedData.length % 2 === 0 
                        ? (sortedData[sortedData.length / 2 - 1] + sortedData[sortedData.length / 2]) / 2
                        : sortedData[Math.floor(sortedData.length / 2)];
                    
                    // Update stats display
                    const statsDiv = document.getElementById('sample-stats');
                    if (statsDiv) {
                        statsDiv.innerHTML = `
                            <div style="margin-top:10px"><strong>Sample Statistics:</strong></div>
                            <div>Mean: ${mean.toFixed(2)}</div>
                            <div>Median: ${median}</div>
                            <div>Std Dev: ${stdDev.toFixed(2)}</div>
                            <div>Range: ${min} to ${max}</div>
                            <div>Sample Size: ${sampleData.length}</div>
                        `;
                    }
                }

                // Update parameter display
                function updateParamDisplay() {
                    const paramsDiv = document.getElementById('distribution-params');
                    if (!paramsDiv) return;
                    
                    const params = distributionParams[currentDistribution];
                    
                    let paramHTML = '<div style="margin-top:5px"><strong>Parameters:</strong></div>';
                    
                    switch (currentDistribution) {
                        case 'binomial':
                            paramHTML += `
                                <div>n (trials): ${params.n}</div>
                                <div>p (probability): ${params.p}</div>
                            `;
                            break;
                            
                        case 'normal':
                            paramHTML += `
                                <div>μ (mean): ${params.mean}</div>
                                <div>σ (std dev): ${params.stddev}</div>
                            `;
                            break;
                            
                        case 'poisson':
                            paramHTML += `
                                <div>λ (lambda): ${params.lambda}</div>
                            `;
                            break;
                            
                        case 'uniform':
                            paramHTML += `
                                <div>a (min): ${params.min}</div>
                                <div>b (max): ${params.max}</div>
                            `;
                            break;
                    }
                    
                    paramsDiv.innerHTML = paramHTML;
                }

                // Create sliders for the current distribution parameters
                function createParameterSliders() {
                    const sliderContainer = document.getElementById('probability-sliders');
                    if (!sliderContainer) return;
                    
                    sliderContainer.innerHTML = '';
                    
                    const params = distributionParams[currentDistribution];
                    
                    switch (currentDistribution) {
                        case 'binomial':
                            // n slider
                            createSlider(sliderContainer, 'n', 'n:', 5, 50, 1, params.n, value => {
                                distributionParams.binomial.n = value;
                                updateParamDisplay();
                            });
                            
                            // p slider
                            createSlider(sliderContainer, 'p', 'p:', 0.05, 0.95, 0.05, params.p, value => {
                                distributionParams.binomial.p = value;
                                updateParamDisplay();
                            });
                            break;
                            
                        case 'normal':
                            // mean slider
                            createSlider(sliderContainer, 'mean', 'μ:', 0, 20, 1, params.mean, value => {
                                distributionParams.normal.mean = value;
                                updateParamDisplay();
                            });
                            
                            // stddev slider
                            createSlider(sliderContainer, 'stddev', 'σ:', 0.5, 5, 0.5, params.stddev, value => {
                                distributionParams.normal.stddev = value;
                                updateParamDisplay();
                            });
                            break;
                            
                        case 'poisson':
                            // lambda slider
                            createSlider(sliderContainer, 'lambda', 'λ:', 0.5, 15, 0.5, params.lambda, value => {
                                distributionParams.poisson.lambda = value;
                                updateParamDisplay();
                            });
                            break;
                            
                        case 'uniform':
                            // min slider
                            createSlider(sliderContainer, 'min', 'min:', 0, 14, 1, params.min, value => {
                                // Make sure min < max
                                if (value < distributionParams.uniform.max) {
                                    distributionParams.uniform.min = value;
                                } else {
                                    // Reset slider to current value if invalid
                                    const slider = document.getElementById('min-slider');
                                    if (slider) slider.value = distributionParams.uniform.min;
                                }
                                updateParamDisplay();
                            });
                            
                            // max slider
                            createSlider(sliderContainer, 'max', 'max:', 1, 20, 1, params.max, value => {
                                // Make sure max > min
                                if (value > distributionParams.uniform.min) {
                                    distributionParams.uniform.max = value;
                                } else {
                                    // Reset slider to current value if invalid
                                    const slider = document.getElementById('max-slider');
                                    if (slider) slider.value = distributionParams.uniform.max;
                                }
                                updateParamDisplay();
                            });
                            break;
                    }
                }

                // Helper function to create a slider
                function createSlider(container, id, label, min, max, step, initialValue, onChangeCallback) {
                    const sliderRow = document.createElement('div');
                    sliderRow.className = 'slider-row';
                    
                    const labelElement = document.createElement('div');
                    labelElement.className = 'slider-label';
                    labelElement.textContent = label;
                    
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.id = id + '-slider';
                    slider.className = 'slider-input';
                    slider.min = min;
                    slider.max = max;
                    slider.step = step;
                    slider.value = initialValue;
                    
                    const valueDisplay = document.createElement('div');
                    valueDisplay.className = 'slider-value';
                    valueDisplay.textContent = initialValue;
                    
                    slider.addEventListener('input', function() {
                        const value = parseFloat(this.value);
                        valueDisplay.textContent = value;
                        onChangeCallback(value);
                    });
                    
                    sliderRow.appendChild(labelElement);
                    sliderRow.appendChild(slider);
                    sliderRow.appendChild(valueDisplay);
                    container.appendChild(sliderRow);
                }

                // Calculate probability for a given range
                function calculateProbability(min, max) {
                    if (sampleData.length === 0) return 0;
                    
                    // Count values in range
                    const countInRange = sampleData.filter(value => value >= min && value <= max).length;
                    
                    // Calculate empirical probability
                    const empiricalProbability = countInRange / sampleData.length;
                    
                    // Calculate theoretical probability
                    let theoreticalProbability = 0;
                    const params = distributionParams[currentDistribution];
                    
                    switch (currentDistribution) {
                        case 'binomial':
                            // Calculate binomial coefficient (n choose k)
                            const binomialCoeff = function(n, k) {
                                let coeff = 1;
                                for (let i = n - k + 1; i <= n; i++) {
                                    coeff *= i;
                                }
                                for (let i = 1; i <= k; i++) {
                                    coeff /= i;
                                }
                                return coeff;
                            };
                            
                            // Sum probabilities for each value in range
                            for (let k = min; k <= max; k++) {
                                if (k >= 0 && k <= params.n) {
                                    const coefficient = binomialCoeff(params.n, k);
                                    const p = params.p;
                                    theoreticalProbability += coefficient * Math.pow(p, k) * Math.pow(1 - p, params.n - k);
                                }
                            }
                            break;
                            
                        case 'normal':
                            // For normal distribution, use the error function approximation
                            function normalCDF(x) {
                                // Error function approximation
                                function erf(x) {
                                    const sign = x < 0 ? -1 : 1;
                                    x = Math.abs(x);
                                    
                                    // Constants for approximation
                                    const a1 =  0.254829592;
                                    const a2 = -0.284496736;
                                    const a3 =  1.421413741;
                                    const a4 = -1.453152027;
                                    const a5 =  1.061405429;
                                    const p  =  0.3275911;
                                    
                                    const t = 1.0 / (1.0 + p * x);
                                    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                                    
                                    return sign * y;
                                }
                                
                                return 0.5 * (1 + erf((x - params.mean) / (params.stddev * Math.sqrt(2))));
                            }
                            
                            // Calculate probability as difference between two CDFs
                            theoreticalProbability = normalCDF(max + 0.5) - normalCDF(min - 0.5);
                            break;
                            
                        case 'poisson':
                            // Calculate Poisson PMF and sum for range
                            for (let k = min; k <= max; k++) {
                                if (k >= 0) {
                                    // Calculate Poisson PMF: (λ^k)(e^-λ)/k!
                                    const lambda = params.lambda;
                                    let probability = Math.exp(-lambda);
                                    
                                    // Calculate λ^k / k!
                                    for (let i = 1; i <= k; i++) {
                                        probability *= lambda / i;
                                    }
                                    
                                    theoreticalProbability += probability;
                                }
                            }
                            break;
                            
                        case 'uniform':
                            // Check that range overlaps with distribution range
                            const lowerBound = Math.max(min, params.min);
                            const upperBound = Math.min(max, params.max);
                            
                            if (lowerBound <= upperBound) {
                                // Calculate uniform probability
                                const numValues = upperBound - lowerBound + 1;
                                const totalValues = params.max - params.min + 1;
                                theoreticalProbability = numValues / totalValues;
                            }
                            break;
                    }
                    
                    // Update display
                    const resultDiv = document.getElementById('probability-result');
                    if (resultDiv) {
                        resultDiv.innerHTML = `
                            <div style="margin-top:10px"><strong>Probability P(${min} ≤ X ≤ ${max}):</strong></div>
                            <div>Empirical: ${(empiricalProbability * 100).toFixed(2)}%</div>
                            <div>Theoretical: ${(theoreticalProbability * 100).toFixed(2)}%</div>
                            <div>Count: ${countInRange} of ${sampleData.length}</div>
                        `;
                    }
                    
                    // Highlight the range on the histogram
                    highlightProbabilityRange(min, max);
                    
                    return {
                        empirical: empiricalProbability,
                        theoretical: theoreticalProbability,
                        count: countInRange
                    };
                }

                // Highlight a range on the histogram
                function highlightProbabilityRange(min, max) {
                    // Store current highlighted range
                    highlightedRange = { min, max };
                    
                    // Remove existing highlight
                    if (probabilityHighlight) {
                        probabilityBoard.removeObject(probabilityHighlight);
                        probabilityHighlight = null;
                    }
                    
                    // Create new highlight polygon
                    const highlightPoints = [];
                    
                    // Find maximum height of bars in range for scaling
                    let maxHeight = 0;
                    histogramBars.forEach((barElements, index) => {
                        const value = min + index;
                        if (value >= min && value <= max && barElements.length > 0) {
                            const barPolygon = barElements.find(el => el.elType === 'polygon');
                            if (barPolygon && barPolygon.vertices) {
                                const height = barPolygon.vertices[2].Y();
                                if (height > maxHeight) maxHeight = height;
                            }
                        }
                    });
                    
                    // Add bottom-left point
                    highlightPoints.push([min - 0.5, 0]);
                    
                    // Add top points for each bar in range
                    for (let value = min; value <= max; value++) {
                        const barIndex = value - min;
                        if (barIndex >= 0 && barIndex < histogramBars.length) {
                            const barElements = histogramBars[barIndex];
                            if (barElements && barElements.length > 0) {
                                const barPolygon = barElements.find(el => el.elType === 'polygon');
                                if (barPolygon && barPolygon.vertices) {
                                    const height = barPolygon.vertices[2].Y();
                                    highlightPoints.push([value - 0.4, height]);
                                    highlightPoints.push([value + 0.4, height]);
                                }
                            }
                        }
                    }
                    
                    // Add bottom-right point
                    highlightPoints.push([max + 0.5, 0]);
                    
                    // Create polygon with points
                    probabilityHighlight = probabilityBoard.create('polygon', highlightPoints, {
                        fillColor: '#f39c12',
                        fillOpacity: 0.4,
                        borders: {
                            strokeWidth: 2,
                            strokeColor: '#d35400'
                        },
                        vertices: {
                            visible: false
                        }
                    });
                    
                    // Update the board
                    probabilityBoard.update();
                }

                // Handle distribution change
                function handleDistributionChange() {
                    const select = document.getElementById('distribution-select');
                    if (!select) return;
                    
                    select.addEventListener('change', function() {
                        currentDistribution = this.value;
                        
                        // Update formula and title
                        document.getElementById('distribution-title').textContent = 
                            this.options[this.selectedIndex].text;
                        document.getElementById('distribution-formula').textContent = 
                            formulas[currentDistribution];
                        
                        // Update parameter sliders
                        createParameterSliders();
                        
                        // Update parameter display
                        updateParamDisplay();
                        
                        // Update overlay if visible
                        if (showDistributionOverlay) {
                            updateDistributionOverlay();
                        }
                    });
                }

                // Initialize the visualization
                function initProbabilityDemo() {
                    // Initialize parameter sliders
                    createParameterSliders();
                    
                    // Update parameter display
                    updateParamDisplay();
                    
                    // Generate initial data
                    generateData();
                    
                    // Set up event handlers
                    handleDistributionChange();
                    
                    // Generate button handler
                    const generateBtn = document.getElementById('probability-generate');
                    if (generateBtn) {
                        generateBtn.addEventListener('click', generateData);
                    }
                    
                    // Calculate probability button handler
                    const calculateBtn = document.getElementById('probability-calculate');
                    if (calculateBtn) {
                        calculateBtn.addEventListener('click', function() {
                            // Show the range selection modal
                            rangeModal.style.display = 'block';
                        });
                    }
                    
                    // Toggle distribution overlay button handler
                    const overlayBtn = document.getElementById('probability-overlay');
                    if (overlayBtn) {
                        overlayBtn.addEventListener('click', function() {
                            showDistributionOverlay = !showDistributionOverlay;
                            
                            if (showDistributionOverlay) {
                                updateDistributionOverlay();
                            } else if (overlayPlot) {
                                probabilityBoard.removeObject(overlayPlot);
                                overlayPlot = null;
                            }
                        });
                    }
                    
                    // Sample size handlers
                    const sampleSizeInput = document.getElementById('sample-size-input');
                    const sampleSizeSlider = document.getElementById('sample-size-slider');
                    
                    if (sampleSizeInput && sampleSizeSlider) {
                        // Sync slider and input
                        sampleSizeInput.addEventListener('input', function() {
                            const value = parseInt(this.value);
                            if (!isNaN(value) && value >= 50 && value <= 5000) {
                                sampleSizeSlider.value = value;
                                sampleSize = value;
                            }
                        });
                        
                        sampleSizeSlider.addEventListener('input', function() {
                            const value = parseInt(this.value);
                            sampleSizeInput.value = value;
                            sampleSize = value;
                        });
                        
                        // Generate new data when sample size changes and slider is released
                        sampleSizeSlider.addEventListener('change', generateData);
                        
                        // Generate new data when input is blurred (user finished editing)
                        sampleSizeInput.addEventListener('blur', function() {
                            // Validate input range
                            let value = parseInt(this.value);
                            if (isNaN(value)) value = 500;
                            if (value < 50) value = 50;
                            if (value > 5000) value = 5000;
                            
                            // Update controls and generate data
                            this.value = value;
                            sampleSizeSlider.value = value;
                            sampleSize = value;
                            generateData();
                        });
                    }
                    
                    // Range modal handlers
                    const applyBtn = document.getElementById('prob-apply');
                    if (applyBtn) {
                        applyBtn.addEventListener('click', function() {
                            const fromValue = parseInt(document.getElementById('prob-from').value);
                            const toValue = parseInt(document.getElementById('prob-to').value);
                            
                            if (!isNaN(fromValue) && !isNaN(toValue) && fromValue <= toValue) {
                                calculateProbability(fromValue, toValue);
                                rangeModal.style.display = 'none';
                            } else {
                                alert('Please enter valid range values where "From" is less than or equal to "To"');
                            }
                        });
                    }
                    
                    const cancelBtn = document.getElementById('prob-cancel');
                    if (cancelBtn) {
                        cancelBtn.addEventListener('click', function() {
                            rangeModal.style.display = 'none';
                        });
                    }
                    
                    console.log("Probability and histogram demonstration initialized");
                }

                // Initialize the visualization
                initProbabilityDemo();
            }

    </script>
</body>
</html>


